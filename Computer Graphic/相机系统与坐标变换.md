## 1. 核心思路：为什么要引入矩阵？

在这一章之前，我们对顶点的操作（如移动、缩放、投影）都是散落在代码各处的“硬算”。

**问题**：如果不统一管理，当我们需要先旋转物体、再平移、再缩放、再做透视投影时，代码会变得极其混乱且难以维护。

**解决方案**：引入**线性代数（矩阵）**。

**逻辑**：所有的几何变换（平移、旋转、缩放、投影）都可以被封装成 $4\times4$ 的矩阵。多个变换可以通过**矩阵乘法**合并成一个“超级矩阵”。

$$v_{final} = M_{viewport} \cdot M_{projection} \cdot M_{modelview} \cdot v_{local}$$

这样，无论变换多复杂，对每个顶点的操作永远只是一次矩阵乘法。

---

## 2. 关键技术：齐次坐标 (Homogeneous Coordinates)

这是本章的基石。

### 这里的逻辑是什么？

普通的 3D 坐标 $(x, y, z)$ 存在一个致命缺陷：**无法用 $3\times3$ 矩阵表示平移（加法）**。线性变换 $Ax$ 永远保持原点不动。

### 解决方案

将维度提升到 4D：$(x, y, z) \to (x, y, z, 1)$。

最后的这个 $1$ 允许我们在矩阵乘法中引入常数项（平移量）。

### 为什么它更好？

1. **统一性**：平移、旋转、缩放全部统一为矩阵乘法，可以自由组合。
    
2. **透视支持**：它允许第 4 个分量 $w \neq 1$，这为处理透视投影（近大远小）提供了数学基础。
    

$$\begin{bmatrix} 1 & 0 & 0 & t_x \\ 0 & 1 & 0 & t_y \\ 0 & 0 & 1 & t_z \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix} = \begin{bmatrix} x + t_x \\ y + t_y \\ z + t_z \\ 1 \end{bmatrix}$$

---

## 3. 三大核心矩阵构建

我们通过构建三个矩阵，将物体从世界空间一步步搬运到屏幕像素。

### A. ModelView 矩阵 (世界 $\to$ 相机)

**目标**：模拟相机拍摄。

**思路**：移动相机太麻烦。不如**保持相机在原点不动，将整个世界反向移动**。

如果相机在 $(0,0,10)$，我们就把世界平移 $(0,0,-10)$。

**LookAt 算法逻辑**：

我们需要构建一个新的坐标系（基变换），以相机为原点：

1. **Z轴 ($n$)**: 视线方向（反向）。
    
2. **X轴 ($l$)**: $Up \times Z$，保证水平。
    
3. **Y轴 ($m$)**: $Z \times X$，保证垂直。
    

**公式**：

$$M_{ModelView} = \begin{bmatrix} l_x & l_y & l_z & 0 \\ m_x & m_y & m_z & 0 \\ n_x & n_y & n_z & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \cdot \begin{bmatrix} 1 & 0 & 0 & -c_x \\ 0 & 1 & 0 & -c_y \\ 0 & 0 & 1 & -c_z \\ 0 & 0 & 0 & 1 \end{bmatrix}$$

_(左边是旋转对齐坐标轴，右边是将相机位置 $c$ 移回原点)_

### B. Perspective 矩阵 (相机 $\to$ 裁剪空间)

**目标**：实现“近大远小”。

**思路**：利用齐次坐标的 $w$ 分量。将深度 $z$ 嵌入到 $w$ 中。当后续进行**透视除法**（除以 $w$）时，距离越远的点（$z$ 越大），分母越大，坐标值就越小。

**公式**：

$$M_{Perspective} = \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & -1/c & 1 \end{bmatrix}$$

变换后点的 $w$ 变为 $1 - z/c$。

**为什么比直接除以 Z 好？**

它保留了矩阵形式的统一性，并且在裁剪（Clipping）阶段，保留 $w$ 分量对于判断点是否在视野内至关重要，避免了直接除以 $z$ 可能导致的除零错误或非线性插值问题。

### C. Viewport 矩阵 (裁剪空间 $\to$ 屏幕空间)

**目标**：将标准化的 $[-1, 1]$ 立方体映射到屏幕分辨率 $[w, h]$。

**思路**：简单的缩放（拉伸）和平移（中心偏移）。

**公式**：

$$M_{Viewport} = \begin{bmatrix} \frac{w}{2} & 0 & 0 & x+\frac{w}{2} \\ 0 & \frac{h}{2} & 0 & y+\frac{h}{2} \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}$$

---

## 4. 最终的光栅化流程 (Rasterization Pipeline)

代码中的 `rasterize` 函数串联了所有步骤：

1. **透视除法 (Perspective Division)**:
    
    $$x_{NDC} = x_{clip} / w, \quad y_{NDC} = y_{clip} / w$$
    
    将 4D 坐标还原为 3D，产生近大远小效果。
    
2. **视口变换**:
    
    $$P_{screen} = M_{Viewport} \cdot P_{NDC}$$
    
    计算出像素坐标。
    
3. **三角形遍历**:
    
    - 使用 **Bounding Box** 缩小遍历范围。
        
    - 计算 **重心坐标 (Barycentric Coordinates)** 判断像素是否在三角形内。
        
4. **Z-Buffer 深度测试**:
    
    - 利用重心坐标插值出当前像素的深度 $z$。
        
    - 比较 `zbuffer[x][y]`，决定是否覆盖像素。
        

---

## 5. 重点答疑：关于 OpenGL API 的设计

### 你的疑惑

> **“我有点好奇，在 OpenGL 内部像这样的一个 rasterization 是有 api 的吧？”**
> 
> _意思是：既然我们手写了一个 `rasterize` 函数来画三角形，OpenGL 里是不是也有一个类似的函数供我们调用？_

### 解答

**答案是：没有。你无法直接调用 OpenGL 的光栅化函数。**

在 OpenGL 中，光栅化（Rasterization）不是一个 API，而是一个**被硬件固化的黑盒阶段**。

#### 为什么这样设计？

1. **硬件性能 (Performance)**:
    
    - 你的 `rasterize` 代码运行在 **CPU** 上，通过 `for` 循环逐个处理像素。
        
    - OpenGL 调用的背后是 **GPU**。GPU 上有专门的电路（Rasterizer Unit）负责这件事。它可以在极短的时间内并行处理成千上万个三角形。为了速度，这部分逻辑被“烧录”在硅片上，不开放给程序员修改。
        
2. **固定管线 vs 可编程管线**:
    
    - **不可改**：你不能改写“如何判断像素在三角形内”的算法。
        
    - **可配置**：虽然不能写逻辑，但你可以通过 API **配置开关**。
        

#### 你的代码 vs OpenGL API 对照表

| **你的手动实现**                   | **OpenGL 对应的配置 API**      | **原理说明**                         |
| ---------------------------- | ------------------------- | -------------------------------- |
| `rasterize()` 函数主体           | **无** (自动发生)              | 当你调用 `glDrawArrays` 时，硬件自动启动光栅化。 |
| `ABC.det() < 1` (背面剔除)       | `glEnable(GL_CULL_FACE)`  | 开启硬件剔除背面三角形功能。                   |
| `if (z < zbuffer[i])` (深度测试) | `glEnable(GL_DEPTH_TEST)` | 开启硬件 Z-Buffer 读写与比较。             |
| `viewport(x,y,w,h)`          | `glViewport(x,y,w,h)`     | 定义屏幕映射范围。                        |
| `bc` (重心坐标插值)                | **自动** (Varying 插值)       | 顶点着色器传给片段着色器的数据，硬件会自动根据重心坐标插值。   |
