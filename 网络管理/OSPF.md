  
# OSPF是什么，以及相对于RIP的优势是什么

OSPF是一种基于链路状态的协议，它的收敛速度很快，以秒为单位，要比RIP块，而且它不受跳数的限制，所以相比于RIP（最多15跳），OSPF可以服务于大型网络。同时它是开放标准的，所以可以多个厂商互通

# 工作原理

1. 发送Hello报文，发现邻居
2. 建立邻里关系，（full状态）
3. 互相交换链路状态信息（LSA）
4. 根据交换来的链路状态信息更新链路状态数据库（LSDB）
5. 更具更新后的链路状态数据库使用SPF算法计算最短路径
6. 生成新的路由表

在第一步和第二步之间，它们是这样建立邻里关系的，假设有R1，R2两台路由器：
1. R1给R2发送Hello报文
2. R2收到Hello报文，识别到R1 是它的邻居，如果看到Hello报文中有自己的route ID，则来到2-way
3. 2-way 双向通信建立，开始交换数据库
4. ExStart确认主从关系（在选举DR/BDR之后）
5. 主从关系确认完毕后，发送LSR请求完整的LSA
6. 加载LSA，同步LSDB
7. 邻里关系正式建立

OSPF的状态机：Down->Init->2-way->Exstart(确认主从)->Exchange->Loading->Full

DR/BDR

DR是指定路由器，因为OSPF的网络很大，如果让路由器之间两两形成邻里关系，会有泛洪问题，消耗大量的带宽，所以要形成拓扑结构，选举出指定DR，让指定路由器来更新链路状态信息，并将链路状态信息广播到其他路由器，DR是一网段为单位进行选举的

```
12.1.1.0/24 该网段可以选举一个DR
12.1.2.0/24 这是另一个网段
```

BDR是备用的DR，当DR挂掉的时候BDR就启用，避免重新选举

选举机制：
1. 优先级最高的成为DR
2. 如果优先级相同，Route ID越大的成为DR
3. 第二名是BDR

## OSPF区域划分

比如一个OSPF内有200台路由器，如果每台路由器都去执行SPF算法，就会非常的耗时，并且大家更新同一个链路状态数据库的时候，会引发LSDB膨胀，内存消耗巨大，另外还会有LSA泛洪问题，一个链路出现抖动，所有的路由器更新LSA，消耗大量带宽

为了解决这个问题，我们可以将这200台路由器分成10个区域，每个20台（每个区域不能超过50台路由器），这样形成10个Area，并且有一个骨干Area0， Area0用来当中转站，转发其他Area过来的流量。这里要注意OSPF区域划分是扁平的，是星形结构。

在每一个Area内部，去更新LSA，LSDB，不会影响其他的Area，这样也可以加速收敛，因为SPF值在区域内计算，然后每一个Area有一个ABR，区域边界路由器，这个路由器将区域内的路由转发到区域外，也就是是Area0连接

```
Area1 - ABR - Area0 - ABR - Area2
```

最后，还有一台ASBR路由器，是引入外部路由的路由器

## LSA的7种类型
1. Type 1: Router LSA, 改LSA由区域中的路由器自己产生，它记录该路由器自己的链路状态信息
2. Type2: Network LSA，由DR路由器产生，描述当前这个网段里面有哪些路由器
3. Type3：Summary LSA，由ABR产生，描述区域间的路由信息
4. Type4: ASBR Summary LSA，由ABR产生，告诉其他区域如何到达ASBR
5. Type5：External LSA，ASBR产生，描述OSPF网络域外的路由信息
6. Type6: Group Membership LSA
7. NSSA External LSA, 可以理解为NSSA专用的type5，描述外部的路由，但是只针对于NSSA； NSSA是不那么末梢的区域

## OSPF区域类型

- 骨干区域：Area0，所有的非骨干区域都需要连接骨干区域，他们之间通过ABR来传递路由信息，骨干区域可以在物理结构上强制保证星形结构，防止环路问题，每一个OSPF网络都必须要有一个骨干区域
- 标准区域：标准区域可以接受type1-5种LSA，每一个标准区域都要连接骨干区域，可以接受外部路由信息，可以进行区域内的SPF计算
- Stub区域：边界区域，不能接受type5，因为type5的LSA信息可能会很多，而且外部路由很容易变化，一旦LSA变化，会触发所有的路由器重新执行SPF计算，消耗大，而划分区域的目的就是为了防止这个问题，stub区域作为边缘区域，用处就是将区域内的路由和外部的隔绝起来，他只需要有默认路由，外部的路由ABR知道可以转发，所以它不能接受
- NSSA区域：不那么末梢的区域，有时候要接受外部路由的情况，所以有Type7类型的LSA，这个就是专门给NSSA区域使用的type5，只能在NSSA区域内传播
- Totally Stub：完全末梢区域，只有Type1，2两种LSA，有默认路由，由ABR转发外部路由信息

## SPF算法原理
SPF其实就是迪杰斯塔拉算法，是一个基于贪心思想的算法，它的执行逻辑：
1. 维护两个集合，确定最小路径的节点集合，候选节点集合
2. 从根节点出发，找到与他相连的所有邻居节点，加入候选，然后分别计算到达这些邻居节点的cost
3. 去cost最小的节点作为下一个节点，加入到确定列表
4. 以当前节点继续寻找与之相邻的节点，计算基于当前节点到达邻居节点的损耗，以此会有三种情况
	1. 如果这个邻居节点已经在确定集合中，直接跳过
	2. 如果这个邻居节点在候选中，则计算到这个节点的cost，如果cost更小了，则更新，否则不更新
	3. 如果从来没有被计算过，加入候选，计算他的cost和路径
5. 以此重复迭代

SPF算法是一个中心往外扩散的无目标的寻路算法

## OSPF的路由汇总

路由汇总的存在是为了减少LSA的数量，缩减路由表，减少LSDB，降低SPF算法带来的性能消耗，
在汇总的时候要注意：
- 只有连续的IP地址段才可以汇总，否则会出现黑洞问题

举例：
```
10.0.1.0/24
10.0.2.0/24
10.0.3.0/24
```
这样是可以汇总的，汇总成`10.0.0.0`

```
10.0.1.0/24
10.0.2.0/24
10.0.3.0/24
10.0.5.0/24
10.0.9.0/24
```
这样就不能汇总，因为如果汇总的话，如果有一条路由是`10.0.4.0`, 他因为汇总传递到这个区域内，但是该区域内没有这个路由，那就出现了黑洞

OSPF路由本质是基于OSPF区域划分而产生的一个优化方案，因为在同一个区域内，我们会人为的让路由的前缀是相同的，那么我可以在某一个ABR路由器上设置，告诉骨干区域说，例如只要是`10.0.0.0`的都是忘我这边发，然后发进来之后再进行下一步的比较和转发


## OSPF 的故障排查

| State     | Desc                         | Reason                                |
| --------- | ---------------------------- | ------------------------------------- |
| Down      | 停留在这里说明完全无法建立双向连接            | 1. 接口没有启用OSPF<br>2. Area ID不对         |
| Init      | 停在这说明只有单向通信，收了hello报文但是对方没响应 | 1. 单向通信<br>2. ACL规则<br>3. 防火墙阻拦了返回的流量 |
| 2-Way     | 停在这里说明点对点链路卡在了2-way          | 1. 网络类型配置错误，本来是p2p的，但是变成了广播           |
| ExStart   | 主从关系选举出现问题                   | 1. MTU不匹配<br>2. RouterID不同            |
| Exchange  | 交换数据库信息的时候出现问题               | 1. MTU问题<br>2. 要交换的LSA太多，导致延迟         |
| Loading   | 请求完整LSA的时候出现问题               | 1. LSR的请求丢包<br>2. LS DB过大，同步超时        |
| Full-down | 出现震荡                         | 1. 链路不稳定<br>2. 接口频繁flap               |
```
邻居无法建立?
├─ 能 ping 通?
│  ├─ 否 → 检查物理层/路由/ACL
│  └─ 是 → 继续
│
├─ 邻居状态是?
│  ├─ Down → 检查 OSPF 配置(Area/认证/定时器)
│  ├─ Init → 检查单向通信/ACL/passive-interface
│  ├─ 2-Way → 检查网络类型配置
│  ├─ Exstart → 检查 MTU
│  ├─ Exchange → 检查 MTU/链路质量/CPU
│  └─ Loading → 检查 LSA 同步/链路质量
│
└─ 邻居反复震荡?
   └─ 检查链路稳定性/Dead timer/CPU/日志
```
