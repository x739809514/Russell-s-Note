# UPCAM-每日分享

# 2024-05-24

## 技术 > 代码优化建议：循环

### 使用前置++运算符

对于迭代器和其他复杂类型，使用前置++运算符效率更高。using "i++" need an additional variable to store the previous value

```c++
Class MyClass{
public:
		MyClass& operator++(){
			//previous add operation
			return *this;
		}
		
		MyClass operator++(int){
			//later add operation
			MyClass temp = *this;
			//change value
			return temp
		}
}
```

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};  
    
// 不推荐  
for (auto it = vec.begin(); it != vec.end(); it++) {  
// 操作  
}  
    
// 推荐  
for (auto it = vec.begin(); it != vec.end(); ++it) {  
// 操作  
}  
```

### 减少循环体内的计算  

把不变的计算提到循环外面，减少循环体内的计算开销。

```cpp
// 不推荐  
for (int i = 0; i < vec.size(); ++i) {  
// 每次循环都会调用vec.size()  
}  
    
// 推荐  
int size = vec.size();  
for (int i = 0; i < size; ++i) {  
// 使用预先计算的size  
}  
```

### 使用范围 `for` 循环

范围 `for` 循环不仅简洁，还能让编译器进行更多优化。

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};  
    
// 不推荐  
for (std::size_t i = 0; i < vec.size(); ++i) {  
int val = vec[i];  
// 操作  
}  
    
// 推荐  
for (auto val : vec) {  
// 操作  
}  
```

### 提前结束循环

在满足条件后立即退出循环，避免不必要的迭代。

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};  
    
// 提前退出循环  
for (auto val : vec)
{  
    if (val == target)
    {  
        break; // 找到目标值后退出循环  
    }
}  
```

### 使用标准库提供的算法来代替手写的循环

标准库算法通常进行了充分优化，并支持 并行计算。

```cpp
const core::Matrix mat;
const int dataSize = 1000000;
core::Vec3Vector pts(dataSize, {1, 2, 3});

// 不推荐
core::Vec3Vector res;
res.reserve(dataSize);
for (const auto& pt : pts)
{
    res.push_back(mat * pt);
}

// 推荐
core::Vec3Vector res = pts;

std::for_each(res.begin(), res.end(), [&] (core::Vec3& pt)
{
    pt = mat * pt;
});

// 并行
std::for_each(std::execution::par, res.begin(), res.end(), [&] (core::Vec3& pt)
{
    pt = mat * pt;
});
```

### 性能测试
```cpp
#include <iostream>
#include <iomanip>
#include <algorithm>
#include <chrono>
#include <execution>
#include <iterator>
#include <TypeName.h>

template<typename Func>
void measureExecutionTime(const std::string& description, Func func)
{
    auto start = std::chrono::high_resolution_clock::now();
    func();
    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> duration = end - start;
    std::cout << std::left << std::setw(50) << description << duration.count() << std::endl;
}

int main()
{
    const core::Matrix mat{
        2, 0, 0, 1,  // x 方向缩放2倍，平移1
        0, 2, 0, 2,  // y 方向缩放2倍，平移2
        0, 0, 2, 3,  // z 方向缩放2倍，平移3
        0, 0, 0, 1   // 齐次坐标
    };

    const int dataSize = 1000000;  // 测试不同的数据量，如100, 1000, 1000000
    core::Vec3Vector pts(dataSize, {1, 2, 3});

    measureExecutionTime("Manual loop with redundant size() calls", [&]
                            {
                                core::Vec3Vector res;
                                res.reserve(dataSize);
                                for (std::size_t i = 0; i < pts.size(); ++i)
                                {
                                    res.push_back(mat * pts[i]);
                                }
                            });

    measureExecutionTime("Manual loop without redundant size() calls", [&]
                            {
                                core::Vec3Vector res;
                                res.reserve(dataSize);
                                for (std::size_t i = 0; i < dataSize; ++i)
                                {
                                    res.push_back(mat * pts[i]);
                                }
                            });

    measureExecutionTime("Range-based for loop", [&]
                            {
                                core::Vec3Vector res;
                                res.reserve(dataSize);
                                for (const auto& pt : pts)
                                {
                                    res.push_back(mat * pt);
                                }
                            });

    measureExecutionTime("std::transform back_inserter", [&]
                            {
                                core::Vec3Vector res;
                                res.reserve(dataSize);
                                std::transform(pts.begin(), pts.end(), std::back_inserter(res), [&] (const core::Point3f& pt)
                                            {
                                                return mat * pt;
                                            });
                            });

    measureExecutionTime("std::for_each", [&]
                            {
                                core::Vec3Vector res = pts;
                                std::for_each(res.begin(), res.end(), [&] (core::Vec3& pt)
                                            {
                                                pt = mat * pt;
                                            });
                            });

    measureExecutionTime("std::for_each with parallel execution", [&]
                            {
                                core::Vec3Vector res = pts;
                                std::for_each(std::execution::par, res.begin(), res.end(), [&] (core::Vec3& pt)
                                            {
                                                pt = mat * pt;
                                            });
                            });

    return 0;
}
```

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/eYVOLwGNEeELqpz2/img/176eadbd-2e2a-4810-8097-bf025c7a351a.png)

## 技术 > 代码优化建议：减少函数级联调用

*   将函数返回值用含义明确的变量名表示，可以提高代码可读性
    
*   如果一定要级联调用，尽量不超过2次调用
    
```cpp
{
    // 不推荐
    auto data = func1() -> func2() -> func3()...

    // 推荐
    auto data1 = func1();
    auto data2 = data1 -> func2();
    auto data3 = data2 -> func3();
    ...
    //auto data3 = data1 -> func2() -> func3(); //2次调用
}

{
    // 不推荐
    auto data = func3(func2(func1(...)))

    // 推荐
    auto data1 = func1();
    auto data2 = func2(data1);
    auto data3 = func3(data2);
    ...
    //auto data3 = func3(func2(data1));  //2次调用
}
```

## 技术 > 代码优化建议：使用短路逻辑运算简化代码

```cpp
// 不推荐
auto exist1(int id) const -> bool
{
    bool isExisted{false};

    std::map<int, std::vector<int>> someData1{};
    decltype(someData1) someData2{};

    auto it1 = someData1.find(id);
    if (it1 != someData1.end())
    {
        isExisted = !it1->second.empty();
    }

    auto it2 = someData2.find(id);
    if (!isExisted && it2 != someData2.end())
    {
        isExisted = !it2->second.empty();
    }

    return isExisted;
}

// 推荐
auto exist2(int id) const -> bool
{
    std::map<int, std::vector<int>> someData1{};
    decltype(someData1) someData2{};

    auto checkExisted = [id] (const decltype(someData1)& someData)
    {
        auto it = someData.find(id);
        return it != someData.end() && !it->second.empty();
    };

    return checkExisted(someData1) || checkExisted(someData2);
}
```

# 2024-05-23

## 技术 > std::optional

`std::optional` 是 C++17 引入的一个模板类，用于表示一个值可能存在也可能不存在的情况。它为开发者提供了一种更安全、更清晰的方式来处理那些可能为空的值。

### 基本用法

#### 创建

可以通过以下几种方式创建 `std::optional`：

```cpp
std::optional<int> opt1;                   // 默认构造，表示没有值
std::optional<int> opt2 = std::nullopt;    // 显式初始化为空
std::optional<int> opt3 = 42;              // 初始化为一个值
std::optional<int> opt4 = opt3;            // 拷贝构造
std::optional<int> opt5 = std::make_optional<int>(7);  // 使用 make_optional
```

#### 检查是否有值

可以使用 `operator bool` 或者 `has_value()` 方法来检查 `std::optional` 是否包含值：

```cpp
if (opt3) {
    // opt3 有值
}

if (opt3.has_value()) {
    // opt3 有值
}
```

#### 获取值

可以通过解引用或 `value()` 方法来获取 `std::optional` 中的值：

```cpp
if (opt3) {
    int value = *opt3;           // 使用解引用
    int value2 = opt3.value();   // 使用 value() 方法
}
```

可以使用 `value_or` 方法提供一个默认值：

```cpp
int value = opt1.value_or(0);    // 如果 opt1 没有值，则使用 0
```

#### 修改值

可以通过赋值操作来修改 `std::optional` 的值：

```cpp
opt1 = 21;       // 赋值一个新值
opt1.reset();    // 清除值，使 opt1 变为空
```

### 适用场景

#### 返回可能为空的值

当函数可能无法返回有效结果时，使用 `std::optional` 可以避免返回特殊的错误值或使用指针。例如：

```cpp
std::optional<int> findInVector(const std::vector<int>& vec, int value) {
    for (int i : vec) {
        if (i == value) {
            return i;
        }
    }
    return std::nullopt;  // 表示未找到
}
```

#### 延迟初始化

当一个对象的初始化依赖于某些条件，且在某些情况下可能不初始化时，可以使用 `std::optional`：

```cpp
std::optional<MyClass> obj;
if (someCondition) {
    obj = MyClass();  // 只有满足条件时才初始化
}
```

#### 传递可选复杂对象

当函数的某些参数是可选的，可以使用 `std::optional` 表示这些参数：

```cpp
void configure(std::optional<Configuration> config = std::nullopt) {
    if (config) {
        // 使用指定的配置
    } else {
        // 使用默认配置
    }
}
```

#### 清晰表达意图

使用 `std::optional` 明确表达某个值是可选的，增强代码的可读性和可维护性，而不必依赖其他的约定或文档说明。

# 2024-05-22

## 技术 > decltype

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/eYVOLwGNEeELqpz2/img/10df8077-bba8-4eb5-94e3-642ef9fd007a.png)

## 技术 > decltype小测试：推导的类型？

```cpp
#include <iostream>
    
template<typename T>
T f();
    
struct S {int a;};
    
int main()
{
    int a = 0;
    S s;
    f<decltype(a)>();
    f<decltype(s.a)>();
    f<decltype(std::move(a))>();
    f<decltype((a))>();
    f<decltype((s.a))>();
    f<decltype(0)>();
}
```

# 2024-05-21

## 技术 > 不要把子线程detach掉，无论出于何种原因

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/eYVOLwGNEeELqpz2/img/f00966a3-53f5-40b9-90ae-767cc5cea4b5.png)

`std::thread`提供了两个主要的方法来处理线程的生命周期：`join()`和`detach()`。`detach()`方法会将线程分离，使其在后台独立运行，而主线程将不会等待它完成。这种方式虽然在某些情况下有用，但一般建议避免使用`detach()`，原因如下：

1.  **资源泄露**：分离的线程在完成后，资源的清理将依赖于操作系统。若线程没有正确清理，会导致资源泄露。
    
2.  **不可控行为**：分离的线程在后台运行，主线程无法控制其执行流程，也无法获取其执行结果，这可能导致难以调试和管理程序的行为。
    
3.  **非确定性**：由于分离的线程无法与主线程同步，可能导致程序的非确定性行为，增加了潜在的竞争条件和死锁的风险。
    

相较之下，使用`join()`方法则更为安全和可控。`join()`会阻塞主线程，直到子线程执行完成。这样可以确保子线程的资源在执行完成后正确地被释放，同时主线程可以安全地获取子线程的执行结果。

# 2024-05-20

## 技术 > Type Alias（类型别名）

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/eYVOLwGNEeELqpz2/img/a2a2adce-5bf1-4277-9fde-dce3d78bd31d.png)

`using`相对于`typedef`有几个显著的好处：

1.  **语法更直观**：
    

`using`的语法更接近普通的变量声明，易于理解。例如：

```cpp
using IntVector = std::vector<int>;
```

这与普通的变量声明类似：

```cpp
int x = 5;
```

1.  **支持模板别名**：
    

`using`支持模板别名，这是`typedef`无法做到的。使用`using`可以创建模板类型别名，而`typedef`只能用于非模板类型。例如：

```cpp
template<typename T>
using Vec = std::vector<T>;

Vec<int> intVec;  // 相当于 std::vector<int> intVec;
```

2.  **一致性和可读性**：
    

`using`语法的一致性更好，尤其是在定义复杂类型时。例如，定义一个指向函数的指针类型时：

```cpp
using FuncPtr = void(*)(int);
```

相比之下，`typedef`会显得比较复杂和难以理解：

```cpp
typedef void(*FuncPtr)(int);
```

3.  **更好的与其他现代C++特性结合**：
    

`using`可以更自然地与其他现代C++特性（如别名模板、auto、decltype等）结合使用，编写的代码更简洁、清晰。例如：

```cpp
template<typename T>
using Ptr = T*;

Ptr<int> p;  // 相当于 int* p;
```

总结来说，`using`不仅语法更加直观和一致，而且提供了`typedef`无法实现的功能（如模板别名）。因此，在现代C++开发中，建议优先使用`using`关键字来定义类型别名。

# 2024-05-18

## 技术 > 重视编译器警告

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/eYVOLwGNEeELqpz2/img/1fb08aa5-3e91-4203-b362-725d99e6b1d6.png)

```cpp
auto func() -> int&
{
    //we4172 # 返回局部变量或临时变量的地址
    int a = 0;
    return a;
}

auto func(bool b) -> int
{
    //we4715 # 不是所有的控件路径都返回值
    if(b){
        return 1;
    }
}

class VClass
{
public:
    virtual auto help() -> void = 0;
    ~VClass(){}
    //we4265 # 类包含虚函数，但其不常用的析构函数不是虚函数；该类的实例可能无法进行正确析构
};

auto func(bool b)
{
    if(b);
    ...
    //we4390 # 找到空的受控语句；这是否是有意的?
}

auto func()
{
    size_t a = 10;
    int b = -9;
    //we4146 # 一元负运算符应用于无符号类型，结果仍为无符号类型
    if(b > -a) 
    {
        
    }
}

auto func()
{
    unsigned int a = -10;
    //we4308 # 负整型常量转换为无符号类型
}

auto func()
{
    int a;
    ++a;
    //we4700 # 使用了未初始化的局部变量
}

auto func(size_t size)
{
    int* p;
    if(size > 255)
    {
        p = new int(10);
    }
    if(p)
    {
        delete p;
    }
    //we4703 # 使用了可能未初始化的本地指针变量
    // 解决：int* p{nullptr};
}

auto func()
{
    int a = -10;
    unsigned int b = a;
    //we4365 # “参数”: 从“int”转换到“size_t”，有符号/无符号不匹配
}

auto func()
{
    const int a = -10;
    unsigned int b = a;
    //we4245 # 从常量“int”转换到“size_t”，有符号/无符号不匹配
}
```

# 2024-05-17

## 技术 > switch和 \[\[fallthrough]]

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/eYVOLwGNEeELqpz2/img/c16e4c15-cb9b-4a03-9534-4b0cd90fb276.png)

注意：

不同编译器下，`[[fallthrough]]`后面不加分号，可能编译不通过。

尽管在我们的开发环境下 不加 `;` 也能编译通过，但从兼容性方面考虑，应当要加上 `;`

# 2024-05-16

## 技术 > RAII

资源获取即初始化（Resource Acquisition Is Initialization，简称 RAII）是一种重要的 C++ 编程技术，它将资源的生命周期绑定到对象的生命周期。这种技术可以应用于多种资源管理场景，如分配的堆内存、执行线程、打开的套接字、打开的文件、锁定的互斥量、磁盘空间、数据库连接等。

### RAII 的核心思想

*   **构造函数获取资源**：当对象被创建时，构造函数负责获取资源。
    
*   **析构函数释放资源**：当对象的生命周期结束时，析构函数负责释放资源。
    

### RAII 的应用场景

RAII 可以应用于以下常见的资源管理场景：

1.  **内存管理**：
    

*   使用智能指针（如 `std::unique_ptr` 和 `std::shared_ptr`）来管理动态分配的内存。这些智能指针在构造时获取内存资源，在析构时自动释放内存。
    

1.  **互斥量管理**：
    
    *   使用 `std::lock_guard` 或 `std::unique_lock` 来管理互斥量的加锁和解锁。这样可以确保互斥量在超出作用域时自动解锁，避免死锁等问题。
    
2.  **线程管理**：
    
    *   使用 `std::thread` 对象来管理线程的启动和终止。线程对象在构造时启动线程，在析构时自动管理线程的联结或分离。
    
3.  **临时阻断信号**：
    
    *   使用 `QSignalBlocker` 可以在构造时阻断信号，并在析构时恢复信号的传递。
        

## 技术 > 使用RAII的lock，不要直接lock和unlock

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/eYVOLwGNEeELqpz2/img/f24aadfc-6fe4-449d-b4b3-1d648e23c55c.png)

# 2024-05-15

## 技术 > 选择合适的stl容器

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/eYVOLwGNEeELqpz2/img/f5f1286d-d31e-4a56-8522-87b8e35a7209.png)

# 2024-05-14

## 技术 > 类型转换：static\_cast、dynamic\_cast、dynamic\_pointer\_cast 和 qobject\_cast

### `static_cast`的使用场景：编译期可以确认的安全转换。

1.  **类层次结构中的转换**
    

*   **上行转换（Derived-to-Base）**：从派生类（子类）转换到基类是安全的，因为派生类对象总是包含一个基类部分。
    
*   **下行转换（Base-to-Derived）**：这种转换是不安全的，因为基类不包含派生类的全部信息。在运行时，如果基类指针或引用实际上不指向一个派生类对象，使用 `static_cast` 进行的下行转换可能会导致不正确的行为。
    

1.  **枚举与整型的转换**
    
2.  **基础数据类型的转换**
    

### `dynamic_cast`的使用场景：运行时类型转换。

1.  **类层次结构中的转换**
    

*   **上行转换**：与 `static_cast` 效果一样，但通常不使用 `dynamic_cast` 因为没有必要进行运行时检查。
    
*   **下行转换**：进行时会检查转换的合法性，如果转换不合法（如基类指针或引用实际上不指向一个派生类对象），则返回 `nullptr`（对于指针）或抛出 `std::bad_cast`（对于引用）。
    

1.  **交叉转换**：在复杂的多重继承情况下，从一个兄弟类转换到另一个兄弟类（都继承自同一个基类），`dynamic_cast` 可以处理这种情况，前提是存在虚函数，从而有虚表来支持运行时类型信息。
    

### `dynamic_pointer_cast`的使用场景：`shared_ptr`智能指针转换

1.  **智能指针转换**：`dynamic_pointer_cast` 可以理解为 `std::shared_ptr` 版本的 `dynamic_cast`。它们两者的核心功能和使用场景是一样的，都是进行安全的运行时类型转换。
    

### `qobject_cast`的使用场景：继承自`QObject`的类

相比 `dynamic_cast`优点

*   **运行时类型检查**：与 `dynamic_cast` 类似，`qobject_cast` 也提供运行时类型检查，但是它专门针对 `QObject` 的继承体系优化。
    
*   **无需 RTTI**：不同于 `dynamic_cast`，`qobject_cast` 不依赖于 C++ 的运行时类型信息（RTTI），它使用 Qt 自身的元对象系统来识别对象类型。
    
*   **性能**：因为 `qobject_cast` 是专门为 `QObject` 设计的，它通常比 `dynamic_cast` 更快。
    

### 总结

*   上行转换总是安全的，下行转换需要谨慎处理。
    
*   如果转换安全性可以在编译期确定，使用 `static_cast`。
    
*   对于运行时类型转换，优先考虑 `dynamic_cast`，特别是需要进行安全性检查时。
    
*   对于智能指针的情况，使用 `dynamic_pointer_cast`。
    
*   对于继承自 `QObject` 的类，考虑使用 `qobject_cast`，它不依赖于 RTTI，并且性能较好。
    

# 2024-05-13

## 技术 > 重要的修饰符（Specifiers）

参数不同、修饰符不同，都意味着 签名不同。

override：重写基类的方法时，必须在函数后面加上override。（改代码过程中，看一处改一处，遇到即重构）

const：类的方法没有修改类成员时，必须在函数后面加上const。比较典型的是所有的Getter函数。（有const约束的时候，任何一个成员函数，隐藏的 \*this）

noexcept：当确定类的方法不会抛出异常时，尽可能加上noexcept。

# 2024-05-09

## 技术 > C++小小小的一个测试，析构时输出什么？

### 示例代码

```cpp
#include <cstdio>
#include <memory>

class Base
{
public:
    Base() {};
    ~Base()
    {
        printf("~Base\n");
    };
};

class Derived : public Base
{
public:
    Derived() {};
    ~Derived()
    {
        printf("~Derived\n");
    };
};

class MyDeleter_unDeletePtr
{
public:
    template<typename T>
    void operator()(T* ptr) const
    {
        printf("MyDeleter_unDeletePtr\n");
    }
};

class MyDeleter_printfBefore
{
public:
    template<typename T>
    void operator()(T* ptr) const
    {
        printf("MyDeleter_printfBefore\n");
        delete ptr;
    }
};

class MyDeleter_printfAfter
{
public:
    template<typename T>
    void operator()(T* ptr) const
    {
        delete ptr;
        printf("MyDeleter_printfAfter\n");
    }
};

int main(int argc, char* argv[])
{
    printf("1. Derived* d = new Derived;\n");
    {
        Derived* d = new Derived;
        delete d;
    }
    printf("\n2. Base* b = new Derived;\n");
    {
        Base* b = new Derived;
        delete b;
    }
    printf("\n3. std::shared_ptr<Base> b(new Derived);\n");
    {
        std::shared_ptr<Base> b(new Derived);
    }
    printf("\n4. std::shared_ptr<Base> b(new Derived, MyDeleter_unDeletePtr());\n");
    {
        std::shared_ptr<Base> b(new Derived, MyDeleter_unDeletePtr());
    }
    printf("\n5. std::shared_ptr<Base> b(new Derived, MyDeleter_printfBefore());\n");
    {
        std::shared_ptr<Base> b(new Derived, MyDeleter_printfBefore());
    }
    printf("\n6. std::shared_ptr<Base> b(new Derived, MyDeleter_printfAfter());\n");
    {
        std::shared_ptr<Base> b(new Derived, MyDeleter_printfAfter());
    }
    return 0;
}
```

### 运行结果
```cpp
1. Derived* d = new Derived;
~Derived
~Base

2. Base* b = new Derived;
~Base

3. std::shared_ptr<Base> b(new Derived);
~Derived
~Base

4. std::shared_ptr<Base> b(new Derived, MyDeleter_unDeletePtr());
MyDeleter_unDeletePtr

5. std::shared_ptr<Base> b(new Derived, MyDeleter_printfBefore());
MyDeleter_printfBefore
~Derived
~Base

6. std::shared_ptr<Base> b(new Derived, MyDeleter_printfAfter());
~Derived
~Base
MyDeleter_printfAfter
```

### 解释

你给他什么类型他就析构什么类型，std::shared\_ptr<Base> bs(static\_cast<Base\*>(new Derived()))，这样就跟上面一样了。

保存的指针是Base，RefCounter是Derived，析构是refcounter代理做的，不是shared\_ptr自己做的。

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/eYVOLwGNEeELqpz2/img/f41ad7ad-5a8b-43f4-8bfc-311cc4eb9e20.png)

```cpp
2. Base* b = new Derived;
~Base
---
静态类型（Static Type）：静态类型是指在编译译时期就能确定的类型，它由指针变量声明时的类型决定。
动态类型（Dynamic Type）：动态类型则是指在程序运行时实际指向的对象的类型。尽管一个指针的静态类型在编译时期固定，但运行时它可能指向不同类型的对象。

指针`b`的静态类型是`Base*`，但它实际上指向一个`Derived`对象的实例（动态类型）。因为`Base`的析构函数没有被声明为`virtual`，在使用`delete`删除`b`时，只会调用`Base`的析构函数，不会调用`Derived`的析构函数。这就导致了派生类部分的资源可能没有被适当地释放，出现了资源泄漏的风险。

3. std::shared_ptr<Base> b(new Derived);
~Derived
~Base
---
**类型推断与多态支持**：`std::shared_ptr` 使用类型模板参数直接指定了被管理的指针类型。当你传递一个`Derived*`给一个`std::shared_ptr<Base>`时，虽然外部类型是`Base*`，但`std::shared_ptr`内部使用删除器会根据实际传递的对象类型`Derived*`来处理，这确保了当智能指针销毁时，会调用`Derived`的析构函数以及`Base`的析构函数。
**内置删除器与类型擦除**：内部机制自动选择或创建与对象实际类型相符的删除器，即使外部声明为基类指针，通过类型擦除技术，智能指针无需直接编码具体类型信息，就能处理各种类型，维持了接口的通用性。
**控制块与资源追踪**：当 `new Derived` 创建一个 `Derived` 类型的对象后，这个对象被传递给 `std::shared_ptr<Base>` 的构造函数。控制块在这时创建，并包含了一个根据实际对象类型推断出的删除器。这确保了当 `std::shared_ptr` 被销毁时，能够适当地释放 `Derived` 对象，调用正确的析构顺序。
**安全性与资源管理**：通过上述机制，显著提升了内存管理的安全性和便捷性。它自动化的引用计数和类型感知删除器设计，避免了手动管理内存时常见的错误，如悬挂指针、重复释放和资源泄漏，尤其在多层继承和复杂对象生命周期管理中优势明显。
```

### 改进代码
```cpp
class Base {
public:
    virtual ~Base() {}
};

class Derived : public Base {
public:
    ~Derived() override {}
};
```